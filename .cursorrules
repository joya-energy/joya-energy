# =========================
# CURSOR RULES FOR JOYA PROJECT (MERN)
# =========================

# === GLOBAL CONTEXT ===
project:
  name: JOYA
  stack: MEAN (MongoDB, Express, Node, Node.js)
  language: TypeScript for backend, JavaScript/TypeScript for frontend
  architecture: Clean Architecture
  principles: Clean Code (Robert C. Martin), SOLID, DRY, KISS, Separation of Concerns
  monorepo: true
  backendRoot: packages/backend
  frontendRoot: packages/frontend

# === GENERAL CODING STYLE ===
rules:
  - Always prefer readability over cleverness.
  - Functions should do one thing only and be small (max ~20 lines ideally).
  - Avoid deeply nested logic. Prefer early returns.
  - Use clear, descriptive variable and function names (no abbreviations).
  - No magic numbers or strings — move them to constants or enums.
  - Avoid side effects in utility functions.
  - Keep imports clean and ordered: external → internal → relative paths.
  - Never commit commented-out code.
  - Use consistent error handling; no silent failures.

# === BACKEND RULES ===
backend:
  - Folder `src/modules` contains feature-specific business logic.
  - Folder `src/interfaces` contains controllers, routes, and request validation.
  - Folder `src/infrastructure` (if created later) handles database, external APIs, etc.
  - Folder `src/domain` (if added) contains entities and core logic.
  - Folder `src/common` holds shared helpers (logging, error types, constants).
  - Folder `src/middlewares` should contain only Express middlewares.
  - Folder `src/utils` for general-purpose stateless functions.
  - Tests live in `src/tests` and should mirror the folder structure of `src`.

  coding-guidelines:
    - Use dependency inversion: high-level modules must not depend on low-level details.
    - Avoid business logic in controllers or routes — keep it in services/modules.
    - Validation happens at the interface level.
    - Use async/await consistently; avoid mixing with `.then()`.
    - Each module exports a clear API surface (index.ts).

  code-style:
    - Use TypeScript types or interfaces consistently.
    - Export only what’s necessary (avoid `export *`).
    - Log meaningful context, not raw errors.
    - Prefer custom error classes in `src/errors`.

# === FRONTEND RULES (if added later) ===
frontend:
You are an expert in TypeScript, Angular, and scalable web application development. You write functional, maintainable, performant, and accessible code following Angular and TypeScript best practices.
## TypeScript Best Practices
- Use strict type checking
- Prefer type inference when the type is obvious
- Avoid the `any` type; use `unknown` when type is uncertain
## Angular Best Practices
- Always use standalone components over NgModules
- Must NOT set `standalone: true` inside Angular decorators. It's the default in Angular v20+.
- Use signals for state management
- Implement lazy loading for feature routes
- Do NOT use the `@HostBinding` and `@HostListener` decorators. Put host bindings inside the `host` object of the `@Component` or `@Directive` decorator instead
- Use `NgOptimizedImage` for all static images.
  - `NgOptimizedImage` does not work for inline base64 images.
## Accessibility Requirements
- It MUST pass all AXE checks.
- It MUST follow all WCAG AA minimums, including focus management, color contrast, and ARIA attributes.
### Components
- Keep components small and focused on a single responsibility
- Use `input()` and `output()` functions instead of decorators
- Use `computed()` for derived state
- Set `changeDetection: ChangeDetectionStrategy.OnPush` in `@Component` decorator
- Prefer inline templates for small components
- Prefer Reactive forms instead of Template-driven ones
- Do NOT use `ngClass`, use `class` bindings instead
- Do NOT use `ngStyle`, use `style` bindings instead
- When using external templates/styles, use paths relative to the component TS file.
## State Management
- Use signals for local component state
- Use `computed()` for derived state
- Keep state transformations pure and predictable
- Do NOT use `mutate` on signals, use `update` or `set` instead
## Templates
- Keep templates simple and avoid complex logic
- Use native control flow (`@if`, `@for`, `@switch`) instead of `*ngIf`, `*ngFor`, `*ngSwitch`
- Use the async pipe to handle observables
- Do not assume globals like (`new Date()`) are available.
- Do not write arrow functions in templates (they are not supported).
## Services
- Design services around a single responsibility
- Use the `providedIn: 'root'` option for singleton services
- Use the `inject()` function instead of constructor injection

# === TESTING ===
testing:
  - Write unit tests for critical modules and utils.
  - Use Jest for backend testing.
  - Naming convention: `<filename>.spec.ts`
  - Each test should verify one behavior.
  - Prefer descriptive test names (“should return 404 if user not found”).
  - Test edge cases and expected failures.

# === ESLINT / CODE QUALITY ===
eslint:
  - Follow Airbnb + Prettier.
  - Disable rules that conflict with TypeScript.
  - Enforce 2-space indentation.
  - Avoid console.log in production code (use logger).

# === GIT / PROJECT HYGIENE ===
git:
  - Commit messages should follow Conventional Commits (`feat:`, `fix:`, `chore:`, `refactor:`).
  - Never commit `.env` or credentials.
  - Always include a meaningful PR description.
  - Keep branches small and focused.

# === DOCUMENTATION & COMMENTS ===
documentation:
  - Each module must have a brief `README.md` explaining its purpose.
  - Use JSDoc-style comments for exported functions or complex logic.
  - Avoid redundant comments (“increment counter” for `count++`).
  - Document architectural decisions in a `/docs/architecture.md` file.

# === AI (Cursor) BEHAVIOR ===
cursor:
  - Always respect the folder boundaries defined above.
  - When generating code, use Clean Architecture layering.
  - Avoid generating code in `dist/` or `node_modules/`.
  - When unsure about structure, default to `src/modules` for domain logic.
  - Prefer writing tests and docs automatically if asked.
  - Suggest refactors aligned with SOLID and readability improvements.
